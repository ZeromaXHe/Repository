# 面试题

**待添加：**

计算机网络：
1. TCP三次握手和四次挥手，为什么不能两次握手
2. TCP协议如何保证传输的可靠性的
3. 说一下拥塞控制
4. cookie和session区别？禁用了cookie还能实现session吗？有大量的session如果都存在服务器的化带来的问题怎么解决？
5. get和post的区别？post为啥需要设计成非幂等性？get方法能带着body吗？
6. https请求流程
7. 输入url后怎样？
8. http和websocket区别；websocket怎么连接？

Java：
1. date的内部实现
2. interface和抽象类区别
3. 包装类的作用

JVM：
1. 介绍一下JVM内存划分吧
2. 介绍垃圾回收算法
3. 有哪些对象可以作为GC Roots
4. CMS回收过程？如何解决内存碎片？cms的并发标记和重新标记之间干了什么?重新标记在干什么?
5. 说一下JMM
6. java虚拟机堆的内存布局？
7. 局部变量表
8. 三色标记-为什么是黑色-增量更新解释-增量更新记录的是什么
9. 内存泄露和内存溢出

算法和数据结构：
1. LRU缓存。链表解决什么问题，哈希表解决什么问题

多线程：
1. ThreadLocal及应用场景
2. 进程和线程的区别？为什么有了进程还要线程？线程之间通信方式？
3. 大量使用volatile会带来啥问题（我说的会导致总线风暴）
4. 说道总线风暴，说一下一致性缓存？
5. 线程状态有哪些

设计模式：
1. 单例模式的实际应用场景？

JUC:
1. ReadWriteLock
2. AQS怎么实现
3. CountDownLatch

分布式：
1. 分布式怎么保证数据一致性

SpringMVC：
1. 说一下MVC?MVC的缺陷是？

Spring：
1. spring怎么实现AOP？
2. spring中到哪些设计模式

SpringCloud：
1. springcloud 服务注册流程

Mybatis：
1. mybatis 分页原理
2. mybatis的支持延迟加载

Elastic Search：
1. ES原理 倒排索引

Redis：
1. redis有哪些高可用方案
2. Redis里面可以对key设置过期时间，这个过期机制是如何实现的
3. ZSET底层数据结构；跳表特性；跳表插入结点，需要经过哪些步骤；Redis的Zset为什么要使用跳表；Zset如何利用跳表实现score排序
4. redis的持久化方式；redis一般怎么用这两种方式？RDB持久化的流程
5. redis的主从；主从同步
6. redis只是单线程的为啥快？redis运行过程中只有单线程吗？有了解最新版本的多线程的redis没？
7. redis模糊匹配指令、list长度指令

MongoDB:
1. mongodb切片

数据库：
1. InnoDB索引的底层数据结构
2. B+树的原理，和B树有什么区别
3. 聚集索引和非聚集索引
4. 最左匹配原则，最左边的第一个字段的值是一样的还能用到索引吗？
5. char和varchar的区别；char类型，如果存储的数组超过长度，会发生什么；varchar的最大长度限制；varchar（1）占用多少空间，后面这个数字代表字节长度还是字符长度
6. mysql指定的编码方式；汉字的字节长度一般是多长
7. 介绍一下MVCC，解决了什么问题，实现原理；多个事务保存多个版本，是否意味着它的数据会被保存多份呢？
8. 为什么最好不要写select *，而是写成select 字段名？
9. 提交读的具体实现
10. mysql的联合索引什么情况会失效

操作系统：
1. 操作系统的epoll、IO模型

## Spring

### Spring的事务

#### 事务的特性

- 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。
- 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。
- 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。

#### Spring事务的配置方式

Spring支持编程式事务管理以及声明式事务管理两种方式。

1. 编程式事务管理
编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。

2. 声明式事务管理
声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。

编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。
显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。

#### 事务的传播机制

事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。
常用的事务传播机制如下：

- PROPAGATION_REQUIRED
Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行
- PROPAGATION_REQUES_NEW
该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可
- PROPAGATION_SUPPORT
如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务
- PROPAGATION_NOT_SUPPORT
该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码
- PROPAGATION_NEVER
该传播机制不支持外层事务，即如果外层有事务就抛出异常
- PROPAGATION_MANDATORY
与NEVER相反，如果外层没有事务，则抛出异常
- PROPAGATION_NESTED
该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。

#### 事务的隔离级别

事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。

在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：

1、 脏读（Dirty read）
脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。
2、 不可重复读（Nonrepeatable read）
不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。
> 不可重复读重点在修改。

3、幻读（Phantom reads）
幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。
> 幻读重点在新增或删除。

在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据业务场景选择不同的隔离级别。

|隔离级别           |含义                         |
|------------------|-----------------------------|
|ISOLATION_DEFAULT	|使用后端数据库默认的隔离级别|
|ISOLATION_READ_UNCOMMITTED	|允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。|
|ISOLATION_READ_COMMITTED	|（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。|
|ISOLATION_REPEATABLE_READ	|（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。|
|ISOLATION_SERIALIZABLE	|完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。|

#### Spring声明式事务配置

事务配置中有哪些属性可以配置?以下只是简单的使用参考

1、事务的传播性：
`@Transactional(propagation=Propagation.REQUIRED)`

2、事务的隔离级别：
`@Transactional(isolation = Isolation.READ_UNCOMMITTED)`
>读取未提交数据(会出现脏读, 不可重复读) 基本不使用

3、只读：
`@Transactional(readOnly=true)`
该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。

4、事务的超时性：
`@Transactional(timeout=30)`

5、回滚：
指定单一异常类：`@Transactional(rollbackFor=RuntimeException.class)`
指定多个异常类：`@Transactional(rollbackFor={RuntimeException.class, Exception.class})`
>该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。

## Java类库

### map的分类

java为数据结构中的映射定义了一个接口java.util.Map,他实现了四个类，分别是：HashMap，HashTable，LinkedHashMap 和 TreeMap

1.HashMap：

最常用的Map，根据键的hashcode值来存储数据，根据键可以直接获得他的值（因为相同的键hashcode值相同，在地址为hashcode值的地方存储的就是值，所以根据键可以直接获得值），具有很快的访问速度，遍历时，取得数据的顺序完全是随机的，HashMap最多只允许一条记录的键为null，允许多条记录的值为null，HashMap不支持线程同步，即任意时刻可以有多个线程同时写HashMap，这样对导致数据不一致，如果需要同步，可以使用synchronziedMap的方法使得HashMap具有同步的能力或者使用concurrentHashMap

2.HashTable：

与HashMap类似，不同的是，它不允许记录的键或值为空，支持线程同步，即任意时刻只能有一个线程写HashTable，因此也导致HashTable在写入时比较慢!

3.LinkedHashMap：

是HashMap的一个子类，但它保持了记录的插入顺序，遍历时先得到的肯定是先插入的，也可以在构造时带参数，按照应用次数排序，在遍历时会比HahsMap慢，不过有个例外，当HashMap的容量很大，实际数据少时，遍历起来会比LinkedHashMap慢（因为它是链啊），因为HashMap的遍历速度和它容量有关，LinkedHashMap遍历速度只与数据多少有关

4.TreeMap：

实现了sortMap接口，能够把保存的记录按照键排序（默认升序），也可以指定排序比较器，遍历时得到的数据是排过序的

什么情况用什么类型的Map：

在Map中插入，删除，定位元素：HashMap

要按照自定义顺序或自然顺序遍历：TreeMap

要求输入顺序和输出顺序相同：LinkedHashMap

## Java并发编程包

### ReentrantLock的公平锁和非公平锁

参考：
https://www.cnblogs.com/fxtx/p/11657021.html
https://zhuanlan.zhihu.com/p/115543000


其实在大家经常使用的ReentrantLock中就有相关公平锁，非公平锁的实现了。

大家还记得我在乐观锁、悲观锁章节提到的Sync类么，是ReentrantLock他本身的一个内部类，他继承了AbstractQueuedSynchronizer，我们在操作锁的大部分操作，都是Sync本身去实现的。

Sync呢又分别有两个子类：FairSync和NofairSync

通过分析ReentrantLock中的公平锁和非公平锁的实现，其中`tryAcquire`是公平锁和非公平锁实现的区别。

下面的两种类型的锁的tryAcquire的实现，从中我们可以看出在公平锁中，每一次的tryAcquire都会检查CLH队列中是否仍有前驱的元素，如果仍然有那么继续等待，通过这种方式来保证先来先服务的原则；

而非公平锁，首先是检查并设置锁的状态，这种方式会出现即使队列中有等待的线程，但是新的线程仍然会与排队线程中的对头线程竞争（但是排队的线程是先来先服务的），所以新的线程可能会抢占已经在排队的线程的锁，这样就无法保证先来先服务，但是已经等待的线程们是仍然保证先来先服务的。

所以总结一下公平锁和非公平锁的区别：

1、公平锁能保证：老的线程排队使用锁，新线程仍然排队使用锁。
2、非公平锁保证：老的线程排队使用锁；但是无法保证新线程抢占已经在排队的线程的锁。

简化版的步骤：（非公平锁的核心）

基于CAS尝试将state（锁数量）从0设置为1

    A、如果设置成功，设置当前线程为独占锁的线程；

    B、如果设置失败，还会再获取一次锁数量，

        B1、如果锁数量为0，再基于CAS尝试将state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；

        B2、如果锁数量不为0或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。 

简化版的步骤：（公平锁的核心）

获取一次锁数量，

    B1、如果锁数量为0，如果当前线程是等待队列中的头节点，基于CAS尝试将state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；

    B2、如果锁数量不为0或者当前线程不是等待队列中的头节点或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。

## Redis

### Redis数据类型以及主要的使用场景

参考 https://www.cnblogs.com/jasonZh/p/9513948.html

1. string（字符串）
2. hash（哈希）
3. list（列表）
4. set（集合）
5. zset（sorted set：有序集合）

string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

    常用命令：get、set、incr、decr、mget等。

    使用场景：常规key-value缓存应用。常规计数: 微博数, 粉丝数。

    实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。

hash 是一个键值(key => value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

    常用命令：hget,hset,hgetall 等。
    
    使用场景：存储部分变更数据，如用户信息等。
    
    实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。

list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

    常用命令：lpush（添加左边元素）,rpush,lpop（移除左边第一个元素）,rpop,lrange（获取列表片段，LRANGE key start stop）等。
    
    使用场景：消息队列系统：使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。比如：将Redis用作日志收集器，实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。
    
    实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
    
set是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。

    常用命令：sadd,spop,smembers,sunion 等。
    
    使用场景：①交集，并集，差集：(Set) ②获取某段时间所有数据去重值
    
    实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。

zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。zadd 命令：添加元素到集合，元素在集合中存在则更新对应score。

    常用命令：zadd,zrange,zrem,zcard等
    
    实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

### 缓存穿透、缓存击穿、缓存雪崩区别和解决方案

1. 缓存穿透

描述：
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：
- 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

2. 缓存击穿

描述：
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

解决方案：
- 设置热点数据永远不过期。
- 加互斥锁

3. 缓存雪崩
  
描述：
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
  
解决方案：
- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
- 设置热点数据永远不过期。

## SQL语言

### drop, delete, truncate的区别

（1）DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。
TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2）表和索引所占空间。
当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，
DELETE操作不会减少表或索引所占用的空间。
drop语句将表所占用的空间全释放掉。

（3）一般而言，drop > truncate > delete

（4）应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5）TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）。

（6）truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7）delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8）truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9）在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为: 
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

## MySQL

### MySQL四个事务隔离级别，默认隔离级别

|事务隔离级别	            |脏读 |不可重复读 |幻读  |
|---------------------------|-----|---------|------|
|读未提交（read-uncommitted）|是	  |是	    |是    |
|不可重复读（read-committed）	|否   |是	    |是    |
|可重复读（repeatable-read）	|否	  |否	    |是    |
|串行化（serializable）	    |否	  |否	    |否    |
 
 mysql默认的事务隔离级别为repeatable-read
 
1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表



**已添加问题：**

